2019.6.13
   文件和目录权限: 
       由11位组成，包括三个3位的域，用于描述所有者、同组用户和其他用户
       每个域有一位表示读权限，一位表示写权限，一位表示执行权限，即rwx
       如 rwxr-x--x，表示所有者拥有读写和执行权限，同组用户可读执行，其他用户只有执行权限
       前两位02000和04000分别表示SETGID位（设置组标识）和SETUID位（设置用户标识），如果某个程序标有了SETUID位，那么用户可以随意设置此程序的用户ID，


   设备文件：
    -- 块设备文件     - 以可随机访问数据块为单元的设备，如磁盘
    -- 字符设备文件   - 以字符流方式进行操作的设备，如打印机、调制解调器等。

   进程空间划分:
   栈区、空闲区、数据区、代码区

   ioctl:
   用于改变终端模式和各种属性

   fcntl:
   用于对文件进行控制

2019.6.14
    
    操作系统组成：
    进程管理 、 i/o设备管理、存储管理 、文件管理
    进程的三种状态:
    运行态： 正在使用cpu时间
    就绪态： 暂时没有分配cpu时间
    阻塞态： 除非某个事件发生，否则不能运行

2019.6.16
    实现互斥的几种方法：
    1、关中断
    2、软件层面，忙等待，如自旋锁
    3、Peterson解决方案-不需要严格轮换的软件互斥算法
    4、TSL解法，由硬件支持的一种自旋锁解法
    自旋锁的一个问题-优先级反转：当某个进程优先级比较高时可能一直处于忙等待状态

2019.6.17
    信号量的实现细节
    对于原语中检测信号量、修改信号量以及必要时使进程睡眠等操作采用关中断的方式保证不可分割性，如果有多个cpu则使用TSL锁保护机制保证同时只有一个CPU访问此信号量。
    互斥与同步不同：同步保证一定事件顺序发生或者不发生
    哲学家进餐问题：针对多个竞争进程访问有限资源 （设置与多个竞争进程相关联的一组信号量）
    读写问题： 针对数据库读写的模型，当有一个写者时，不能读 （P65）
    计算密集型： 大部分时间花在运算上
    I/O密集型：  在I/O请求之间需要较少的CPU运算

2019.6.18
    根据如何处理中断把调度算法分为以下两类:
    非抢占式调度算法：挑选一个程序运行，并一直运行到此进程阻塞或退出
    抢占式调度算法：程序的最大运行时间是固定的，需要时间中断获取cpu的控制权

    不同系统调度器的目标不同：
    批处理：可以采用非抢占式，没有终端用户
    交互式：需要抢占式，有终端用户
    实时：所有程序都在推进当前应用，可能在不断阻塞，因此非抢占式也可以

    最短作业优先：对日常工作的安排有启发，优先做那些耗时短的工作

    交互式系统调度器：
    内存调度
    
    cpu调度:时间片轮转(最简单)

2019.6.19
    操作系统启动
    软盘 ：加载引导程序 ===》 装载boot程序 ====》 引入操作系统
    硬盘启动 : 读分区记录表 ===》 选择活动分区 ===》 装载boot ===> 引入操作系统
